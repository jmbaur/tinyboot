const std = @import("std");

/// A read-only legacy Master Boot Record partition table
const Mbr = @This();

pub const Error = error{
    InvalidHeaderSize,
    MissingMagicNumber,
};

const boot_magic = 0x55aa;

header: *Header,

/// Caller is responsible for source.
pub fn init(source: *std.io.StreamSource) !Mbr {
    var header_bytes: [@sizeOf(Header)]u8 = undefined;
    const bytes_read = try source.reader().readAll(&header_bytes);
    if (bytes_read != @sizeOf(Header)) {
        return Error.InvalidHeaderSize;
    }
    const aligned_buf = @as([]align(@alignOf(Header)) u8, @alignCast(&header_bytes));

    const header: *Header = @ptrCast(aligned_buf);

    if (std.mem.bigToNative(@TypeOf(header.signature), header.signature) != boot_magic) {
        return Error.MissingMagicNumber;
    }

    return .{
        .header = header,
    };
}

pub fn identifier(self: *const Mbr) u32 {
    return std.mem.littleToNative(@TypeOf(self.header.unique_mbr_signature), self.header.unique_mbr_signature);
}

pub fn partitions(self: *const Mbr) [4]PartitionRecord {
    return self.header.partition_records;
}

const Header = extern struct {
    boot_code: [440]u8,
    unique_mbr_signature: u32 align(2),
    unknown: u16,
    partition_records: [4]PartitionRecord align(2),
    signature: u16,
};

const PartitionRecord = extern struct {
    boot_indicator: u8,
    start_head: u8,
    start_sector: u8,
    start_track: u8,
    os_type: u8,
    end_head: u8,
    end_sector: u8,
    end_track: u8,
    starting_lba: u32,
    size_in_lba: u32,

    const bootable_flag = 0x80;

    pub fn isBootable(self: *const @This()) bool {
        return self.boot_indicator == bootable_flag;
    }

    pub fn partType(self: *const @This()) u8 {
        return self.os_type;
    }
};

pub const PartitionType = enum {
    Fat16,
    ProtectedMbr,
    LinuxExtendedBoot,
    EfiSystemPartition,

    pub fn fromValue(val: u8) ?@This() {
        return switch (val) {
            0x06 => .Fat16,
            0xea => .LinuxExtendedBoot,
            0xee => .ProtectedMbr,
            0xef => .EfiSystemPartition,
            else => return null,
        };
    }
};

test "mbr parsing" {
    // Disk /dev/sda: 504 MiB, 528482304 bytes, 1032192 sectors
    // Disk model: QEMU HARDDISK
    // Units: sectors of 1 * 512 = 512 bytes
    // Sector size (logical/physical): 512 bytes / 512 bytes
    // I/O size (minimum/optimal): 512 bytes / 512 bytes
    // Disklabel type: dos
    // Disk identifier: 0xbe1afdfa
    //
    // Device     Boot Start     End Sectors  Size Id Type
    // /dev/sda1  *       63 1032191 1032129  504M  6 FAT16
    const partition_table: []const u8 = &.{
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0xfd, 0x1a, 0xbe, 0x00, 0x00, 0x80, 0x01,
        0x01, 0x00, 0x06, 0x0f, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0xc1, 0xbf, 0x0f, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa,
    };

    var source = std.io.StreamSource{
        .const_buffer = std.io.fixedBufferStream(partition_table),
    };

    var disk = try Mbr.init(&source);

    try std.testing.expectEqual(@as(u32, 0xbe1afdfa), disk.identifier());
    const mbr_partitions = disk.partitions();
    try std.testing.expect(mbr_partitions[0].isBootable());
    try std.testing.expectEqual(@as(u8, 0x06), mbr_partitions[0].partType());
}
