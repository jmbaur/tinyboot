const std = @import("std");

/// A read-only legacy Master Boot Record partition table
const Mbr = @This();

const boot_magic = std.mem.bigToNative(u16, 0x55aa);

header: Header,

/// Caller is responsible for source.
pub fn init(stream: *std.io.StreamSource) !Mbr {
    comptime std.debug.assert(@sizeOf(Header) == 512);

    const header = try stream.reader().readStructEndian(Header, .little);

    if (header.signature != boot_magic) {
        return error.InvalidMbr;
    }

    return .{ .header = header };
}

pub fn identifier(self: *const Mbr) u32 {
    return std.mem.littleToNative(@TypeOf(self.header.unique_mbr_signature), self.header.unique_mbr_signature);
}

pub fn partitions(self: *const Mbr) [4]PartitionRecord {
    return self.header.partition_records;
}

const Header = extern struct {
    boot_code: [440]u8 align(1),
    unique_mbr_signature: u32 align(1),
    unknown: u16 align(1),
    partition_records: [4]PartitionRecord,
    signature: u16 align(1),
};

const PartitionRecord = extern struct {
    boot_indicator: u8,
    start_head: u8,
    start_sector: u8,
    start_track: u8,
    os_type: u8,
    end_head: u8,
    end_sector: u8,
    end_track: u8,
    starting_lba: u32 align(1),
    size_in_lba: u32 align(1),

    const bootable_flag = 0x80;

    pub fn isBootable(self: *const @This()) bool {
        return self.boot_indicator == bootable_flag;
    }

    pub fn partType(self: *const @This()) u8 {
        return self.os_type;
    }
};

pub const PartitionType = enum {
    Fat16,
    ProtectedMbr,
    LinuxExtendedBoot,
    EfiSystemPartition,

    pub fn fromValue(val: u8) ?@This() {
        return switch (val) {
            0x06 => .Fat16,
            0xea => .LinuxExtendedBoot,
            0xee => .ProtectedMbr,
            0xef => .EfiSystemPartition,
            else => return null,
        };
    }
};

test "mbr parsing" {
    // Disk /dev/sda: 504 MiB, 528482304 bytes, 1032192 sectors
    // Disk model: QEMU HARDDISK
    // Units: sectors of 1 * 512 = 512 bytes
    // Sector size (logical/physical): 512 bytes / 512 bytes
    // I/O size (minimum/optimal): 512 bytes / 512 bytes
    // Disklabel type: dos
    // Disk identifier: 0xbe1afdfa
    //
    // Device     Boot Start     End Sectors  Size Id Type
    // /dev/sda1  *       63 1032191 1032129  504M  6 FAT16
    const partition_table= [_]u8{
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0xfd, 0x1a, 0xbe, 0x00, 0x00, 0x80, 0x01,
        0x01, 0x00, 0x06, 0x0f, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0xc1, 0xbf, 0x0f, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa,
    };

    var stream = std.io.StreamSource{ .const_buffer = std.io.fixedBufferStream(&partition_table) };

    var disk = try Mbr.init(&stream);

    try std.testing.expectEqual(@as(u32, 0xbe1afdfa), disk.identifier());
    const mbr_partitions = disk.partitions();
    try std.testing.expect(mbr_partitions[0].isBootable());
    try std.testing.expectEqual(@as(u8, 0x06), mbr_partitions[0].partType());
}
